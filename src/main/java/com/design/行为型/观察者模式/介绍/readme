观察者论述
    观察者(Observer Pattern)模式,也称发布订阅模式
        定义对象间一种一对多的依赖关系,使得每当一个对象改变状态,则所有依赖于它的对象都会得到通知并被自动更新。
        一般情况下,被依赖的对象叫作被观察者,,依赖的对象叫作观察者,。不过,在实际的项目开发中,这两种对象的称呼是比较灵活的,有各种不同的叫法,
        比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。
        不管怎么称呼,只要应用场景符合刚刚给出的定义,都可以看作观察者模式。
        
    观察者理论
        抽象主题(Subject)角色：该角色又称为“被观察者”,可以增加和删除观察者对象。
        抽象观察者(Observer)角色：该角色为所有的具体观察者定义一个接口,在得到主题的通知时更新自己。
        具体主题(Concrete Subject)角色：该角色又称为“具体被观察者”,它将有关状态存入具体观察者对象,在具体主题的内部状态改变时,给所有登记过的观察者发出通知。
        具体观察者(Concrete Observer)角色：该角色实现抽象观察者所要求的更新接口,以便使自身的状态与主题的状态相协调。

    什么时候用策略模式？
        1· 关联行为场景。
        2· 事件多级触发场景
        3· 跨系统的消息交换场景，如消息队列的处理机制

    优点：
        · 观察者和被观察者之间是抽象耦合。被观察者角色所知道的只是一个具体观察者集合，每一个具体观察者都符合一个抽象观察者的接口。
                  被观察者并不认识任何一个具体的观察者，它只知道它们都有一个共同的接口。
                  由于被观察者和观察者没有紧密的耦合在一起，因此它们可以属于不同的抽象化层次，且都非常容易扩展。
        · 支持广播通信。被观察者会向所有登记过的观察者发出通知，这就是一个触发机制，形成一个触发链。
    缺点：
        · 如果一个主题有多个直接或间接的观察者，则通知所有的观察者会花费很多时间，且开发和调试都比较复杂。
        · 如果在主题之间有循环依赖，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式时要特别注意这一点
        · 如果对观察者的通知是通过另外的线程进行异步投递，系统必须保证投递的顺序执行
        · 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有提供相应的机制使观察者知道所观察的对象是如何发生变化