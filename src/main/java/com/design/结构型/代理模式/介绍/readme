代理模式论述:
        代理模式是一种常见的结构性模式,给某一个对象提供代理,并由代理控制对源对象的引用,此时可以通过一个称之为代理层对象,类似中介,
            来实现客户端与目标端的链接作用,并且可以通过代理对象去掉客户端无需看到的额外资源与服务。

我们为什么需要代理模式?
        降低耦合度：代理模式作为代理层可以协调调用者及被调用者,一定程度解决了耦合性的问题
        高性能：通过远程代理对可以访问远程机器的对象,这样更加具有性能上的提升空间可进行数据计算分析等,并且通过一个代理的小对象可以控制一个大对象,
            减少了资源开销,对系统进行了优化并提高了运行速度
        安全性：通过代理层可校验被调用者的权限

代理模式理论
    代理模式(Proxy):
        通过引入代理对象的方式来间接访问目标对象,防止直接访问目标对象给系统带来不必要的复杂性

    什么时候用代理模式？
        1.需要屏蔽的真实对象的部分服务功能

    如何看待代理模式的角色？
                        抽象主题
                           |
                   request | request
                  |--------|---------|
                  |                  |
                  ↓                  ↓
               真实主题 <------------ 代理类
                        代理设计模式
         抽象主题：通过接口或者抽象类声明真实主题和代理对象的实现的业务方法
         真实主题：实现抽象主题中的具体业务,是代理对象所表示的真实对象,也是最终引用的对象
         代理角色：提供了与真实主题的相同接口,其中内部包含对真实主题的引用,可以包含访问、控制、扩展真实主题的功能。
    代理模式
        优点：
            通过代理降低了调用者及被调用者之间的耦合性代理对象作为客户端及目标对象之间的中介,起到保护目标对象的作用,
                并可以做出相应扩展功能。
        缺点：
            由于调用者及被调用者之间增加了代理对象,因此会造成请求处理变慢实现代理模式需要额外的工作,从而增加系统实现的复杂度

    静态代理的缺点：
        一方面,我们需要在代理类中,将原始类中的所有的方法,都重新实现一遍,并且为每个方法都附加相似的代码逻辑。
        另一方面,如果要添加的附加功能的类有不止一个,我们需要针对每个类都创建一个代理类。

    动态代理：JDK和CGLIB
        JDK代理要求被代理的类必须实现接口,有很强的局限性。而CGLIB动态代理则没有此类强制性要求。
        简单的说,CGLIB会让生成的代理类继承被代理类,并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。
        但是如果被代理类被final修饰,那么它不可被继承,即不可被代理；同样,如果被代理类中存在final修饰的方法,那么该方法也不可被代理

    在mybatis和spring中的应用
        mybatis中获取代理对象后进行调用 jdk代理
        spring aop中JdkDynamicAopProxy